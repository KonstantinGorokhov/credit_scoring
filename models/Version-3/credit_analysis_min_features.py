"""Анализ кредитных заявок для выявления минимального набора признаков.

Этот скрипт выполняет разведочный анализ данных (EDA) с целью
определения минимального, но эффективного набора признаков для
базовой оценки кредитного риска.

Основные шаги анализа:
1.  Загрузка и объединение данных о заявках и дефолтах.
2.  Очистка данных: удаление пропусков и преобразование типов.
3.  Расчет базового уровня дефолт-рейта для сравнения.
4.  Анализ отдельных признаков:
    - `appl_rej_cnt` (количество отказов)
    - `out_request_cnt` (количество внешних запросов)
    - `region_rating` (рейтинг региона)
    - `Score_bki` (скоринговый балл БКИ)
5.  Формулирование простого правила (фильтра) на основе
    выбранных признаков.
6.  Оценка эффективности правила: доля одобренных заявок и
    их дефолт-рейт.
"""
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

pd.set_option('display.max_columns', 100)


# ===================================
#      1. ЗАГРУЗКА И ОБЪЕДИНЕНИЕ ДАННЫХ
# ===================================
# Даны две таблицы:
# - `application_info.csv` — характеристики заявок,
# - `default_flg.csv` — информация о дефолте.
# Таблицы объединяются по идентификатору заявки `id`.

try:
    app = pd.read_csv('application_info.csv')
    dfl = pd.read_csv('default_flg.csv')
    df = app.merge(dfl, on='id')
except FileNotFoundError:
    print("Ошибка: Файлы данных не найдены. Убедитесь, что 'application_info.csv' и 'default_flg.csv' находятся в той же директории.")
    exit()

df.head()


# ===================================
#      2. ОЧИСТКА ДАННЫХ
# ===================================
# - Пропуски удаляются.
# - Используется только выборка с известным значением `default_flg`.

df = df.dropna().copy()
df['default_flg'] = df['default_flg'].astype(int)

print('Размер выборки после очистки:', df.shape)
print('Средний дефолт-рейт по выборке:', round(df["default_flg"].mean(), 4))


# ===================================
#      3. РАСЧЕТ БАЗОВОГО УРОВНЯ РИСКА
# ===================================
# Общий дефолт-рейт по всей выборке, который будет использоваться
# как точка отсчета для сравнения.

base_dr = df['default_flg'].mean()
print(f'Базовый дефолт-рейт: {base_dr:.4f}')


# ===================================
#      4. АНАЛИЗ ОТДЕЛЬНЫХ ПРИЗНАКОВ
# ===================================
# Для каждого признака рассчитывается дефолт-рейт по его значениям,
# чтобы оценить, есть ли выраженная разница в риске и можно ли
# использовать признак как простой фильтр.

def simple_analysis(col: str) -> pd.DataFrame:
    """Рассчитывает статистику дефолтов по группам признака.

    Args:
        col: Название столбца для анализа.

    Returns:
        DataFrame со статистикой (количество, дефолт-рейт)
        по каждому значению признака.
    """
    tab = (
        df.groupby(col)['default_flg']
        .agg(['count', 'mean'])
        .rename(columns={'mean': 'default_rate'})
        .sort_values('default_rate')
    )
    return tab

# Анализ влияния количества отказов
display("Анализ по 'appl_rej_cnt'", simple_analysis('appl_rej_cnt'))

# Анализ влияния количества внешних запросов
display("Анализ по 'out_request_cnt'", simple_analysis('out_request_cnt').head(10))

# Анализ влияния рейтинга региона
display("Анализ по 'region_rating'", simple_analysis('region_rating'))

# Анализ 'Score_bki' через квантильные группы (корзины)
df['score_bin'] = pd.qcut(df['Score_bki'], 5, duplicates='drop')
display("Анализ по 'Score_bki'", df.groupby('score_bin')['default_flg'].agg(['count', 'mean']))

# Выводы по признакам:
# - Наличие хотя бы одного отказа (`appl_rej_cnt > 0`) резко увеличивает риск.
# - Большое число внешних запросов также связано с повышенным риском.
# - Региональный рейтинг и кредитный скор (`Score_bki`) демонстрируют
#   монотонную связь с уровнем дефолта.


# ===================================
#      5. ВЫБОР МИНИМАЛЬНОГО НАБОРА ПРИЗНАКОВ
# ===================================
# На основе анализа отбирается минимальный набор, который сильно и
# интерпретируемо влияет на риск.
#
# Выбранные признаки:
# 1. `Score_bki` — основной индикатор кредитного риска.
# 2. `appl_rej_cnt` — история отказов.
# 3. `out_request_cnt` — кредитная активность.
# 4. `region_rating` — региональный фактор.

# Формулировка простого правила для отбора "хороших" заявок
rule = (
    (df['Score_bki'] <= -1.7) &
    (df['appl_rej_cnt'] == 0) &
    (df['out_request_cnt'] <= 3) &
    (df['region_rating'] >= 50)
)

approved = df[rule]

print('Доля заявок, проходящих через фильтр:', round(len(approved) / len(df), 3))
print('Дефолт-рейт в отобранной группе:', round(approved["default_flg"].mean(), 3))
print('Сравнение с базовым дефолт-рейтом:', round(base_dr, 3))


# ===================================
#      6. ИТОГОВЫЕ ВЫВОДЫ
# ===================================
# 1. Для базовой фильтрации заявок может быть достаточно небольшого
#    числа признаков.
# 2. Наиболее значимым одиночным фактором является кредитный скор (`Score_bki`).
# 3. Комбинация нескольких простых признаков позволяет существенно
#    снизить кредитный риск в отобранном сегменте.